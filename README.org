
* Overview
A collection of tools I've built to carry out various tasks with LLMs in emacs.
The tools primarily provide ways of providing text as context to gptel.  I
currently focus on extracting text from research manuscript pdfs and reading
source code and function documentation within emacs.

* Background
The gptel tools thread (https://github.com/karthink/gptel/issues/514) describes tool use:

"'Tool use' or 'function calling' is LLM usage where

    - You include a function specification along with your task/question to the
      LLM.
    - The LLM optionally decides to call the function, and supplies the function
      call arguments.
    - You run the function call, and (optionally) feed the results back to the
      LLM. gptel handles this automatically.
    - The LLM completes the task based on the information received.

You can use this to give the LLM awareness of the world, by providing access to
APIs, your filesystem, web search, Emacs etc. You can get it to control your
Emacs frame, for instance."

* pdf Processing
These functions extract the text from a pdf viewed in an emacs buffer.  They
won't work on pdfs that don't have embedded text, e.g., document scans.  Presets
allow the user to enter queries like "@websearch, find a web link to reference
4."

#+BEGIN_SRC emacs-lisp :results silent 
(defun get-text-to-process ()
  "Return the contents of the current pdf page as text."
  (interactive)
  (let ((current-buffer (current-buffer))
        (current-window (selected-window))
        (text-buffer)
        (text-content))
    (dolist (w (window-list))
      (select-window w)
      (when (eq major-mode 'pdf-view-mode)
        (setq text-buffer (current-buffer)
              text-content
              (pdf-info-gettext
               (pdf-view-current-page) '(0 0 1 1)))))
    (select-window current-window)
    (when (not (eq (current-buffer) current-buffer))
      (switch-to-buffer current-buffer))
    text-content))

(gptel-make-tool
 :function #'get-text-to-process
 :name "process_supplied_text"
 :description "use supplied text to answer a question"
 :args nil
 :category "knowledge")
;; also give the preset the ability to
;; do web searches, e.g., to get a PMID
;; for a reference or additional details 
(gptel-make-preset 'text-processor
  :description  "use the text supplied to carry out the user's request"
  :tools        '("process_supplied_text" "brave_search"))

(defun gptel-add-current-pdf-page-text-to-context ()
  "Add the text from a pdf's current page to gptel's context."
  (interactive)
  (let ((pdf-text (get-text-to-process)))
    (with-current-buffer (get-buffer-create "*text-processing*")
      (delete-region (point-min) (point-max))
      (insert pdf-text)
      (gptel-context--add-region
       (current-buffer) (point-min) (point-max) t))
    ))

;; need to add osx equivalent to 'gnome-screenshot'
(defun gptel-add-current-pdf-page-image-to-context ()
  "Add the text from a pdf's current page to gptel's context."
  (interactive)
  (let ((default-directory "~")
        (window-config (window-configuration-to-register ?E))
        (pdf-buffer))

    (when (file-exists-p "/tmp/shot.png")
      (async-shell-command "rm /tmp/shot.png" nil nil)
      )

    (dolist (w (window-list))
      (with-current-buffer (window-buffer w)
        (when (eq major-mode 'pdf-view-mode)
          (setq pdf-buffer (current-buffer)))))

    (if (not pdf-buffer)
        (message "No pdf buffer detected.")
      (progn
        (switch-to-buffer pdf-buffer)
        (delete-other-windows)
        (start-process-shell-command "" nil
         "/usr/bin/gnome-screenshot -w -f /tmp/shot.png")
        (while (not (file-exists-p "/tmp/shot.png"))
          (sit-for 0.1))
        (gptel-context-add-file "/tmp/shot.png")
        (jump-to-register ?E))
        )))

;; add the text from all pages of a pdf to gptel's context
;; call with a prefix arg to specify a page range: 
(defun gptel-add-all-pdf-text-to-context (arg)
  "Return the entirety of the text you wish to process and add it to
gptel's context.  With a prefix argument, set a range of pages to cover."
  (interactive "P")
  (let* ((current-page)
         (last-page)
         (current-buffer (current-buffer))
         (current-window (selected-window))
         (pdf-window)
         (text-content)
         (page-range))

    ;; prefix arg supplied: specify a page
    ;; range rather than the full pdf:
    (when
        (not (= (prefix-numeric-value arg) 1))
      (setq page-range (list (read-number "start of page range: ")
                             (read-number "end of page range: "))))

    ;; find the pdf buffer:
    (dolist (w (window-list))
      (select-window w)
      (when (eq major-mode 'pdf-view-mode)
        (setq pdf-window (selected-window)
              current-page (pdf-view-current-page)
              last-page (progn (pdf-view-last-page)
                               (pdf-view-current-page)))
        (pdf-view-goto-page current-page))
      )

    ;; send the text to gptel:
    (select-window pdf-window)
    (dolist (n (if page-range
                   (number-sequence (car page-range)
                                    (car (cdr page-range)))
                 (number-sequence 1 last-page)))
      (pdf-view-goto-page n)
      (setq text-content
            (concat text-content
                    (pdf-info-gettext
                     (pdf-view-current-page) '(0 0 1 1)))))
    (select-window pdf-window)
    (pdf-view-goto-page current-page)
    (select-window current-window)
    (with-current-buffer (get-buffer-create "*text-processing*")
      (delete-region (point-min) (point-max))
      (insert text-content)
      (gptel-context--add-region
       (current-buffer) (point-min) (point-max) t))))

#+END_SRC

* Prompt From and Respond Through the Minibuffer
This function prompts the user for a query and echoes a response through the
minibuffer without having to call the gptel transient menu. 

#+BEGIN_SRC emacs-lisp :results silent 
;; note: context added via gptel menu is not accessible using this command
(defun gptel-send-prompt-to-minibuffer-echo-area (arg)
  "Prompt for input, send to LLM, and display response in echo area."
  (interactive "P")
  (let ((prompt (read-string "Send to LLM: "))
        (val (prefix-numeric-value arg)))
    (gptel-request
     prompt
     :callback (lambda (response _info)
                 (if (= val 1)
                     (when (stringp response)
                       (message "%s" response))
                   (when (stringp response)
                     (insert "%s" response))
                   )))))
#+END_SRC

* Reading and Analyzing Source Code
I use 'etags' to find source code definitions of functions and variables.  My
tags files are set up with the following configuration:

#+BEGIN_SRC bash
## -----
## setup:

## make sure we have etags:
which etags

## make tags directory:
mkdir -p ~/.emacs.d/TAGS
touch ~/.emacs.d/TAGS/TAGS

## -----
## run etags program:
cd  ~/.emacs.d/TAGS
## see:
## https://stackoverflow.com/questions/10738219/how-to-use-shell-magic-to-create-a-recursive-etags-using-gnu-etags
find ~/.emacs.d/ -type f \( -name "*.el" -o -name "*.elc" -o -name "*.c" -o -name "*.h" \) -print | etags - -o TAGS
#+END_SRC 

With this setup, I use emacs built-in xref to find source code and provide it to
gptel.  I have two functions: One provides only the function / variable of
interest, while the other provides the entirety of the source code file for a
given definition.  

#+BEGIN_SRC emacs-lisp :results silent 
(defun provide-gptel-symbol-definition (symbol)
  "Get the documentation for 'symbol' (function or variable) via 'xref' and supply to the llm.  I use 'ivy-xref', which seems to simplify finding xrefs vs. the default, which splits the window and asks you to select among options."
  (let ((current-buf (current-buffer))
        (code-def)
        (code-buf))

    (cond
     ;; no 'xref' matches to symbol:
     ((= 0 (length
            (xref-backend-definitions
             (xref-find-backend) symbol)))
      (setq code-def "Multiple matches to symbol.  Can't provide code."))
     
     ;; more than 1 'xref' match to symbol:
     ((< 1 (length
            (xref-backend-definitions
             (xref-find-backend) symbol)))
      (let* ((xrefs (xref-backend-definitions
                     (xref-find-backend)
                     symbol)))
        (dolist (xr xrefs)
          (let* ((location (xref-item-location xr))
                 (marker (xref-location-marker location)))
            (with-current-buffer (marker-buffer marker)
              (save-excursion
                (goto-char marker)
                (mark-defun)
                (setq code-def (concat
                                "\n"
                                code-def
                                (buffer-substring-no-properties
                                 (point) (mark))))))
            (kill-buffer (marker-buffer marker))))))
     
     ;; single 'xref' match to symbol:
     ((= 1 (length
            (xref-backend-definitions
             (xref-find-backend) symbol)))
      (progn
        (xref-find-definitions symbol)
        (mark-defun)
        (setq code-def (buffer-substring-no-properties
                        (point) (mark))
              code-buf (current-buffer))
        (when (not (eq current-buf code-buf))
          (kill-buffer code-buf))))

     ;; 'cond' contingency
     (t
      (message "Unknown error.")))
    ;; provide code to gptel:
    code-def))

;; examples of testing this function:
;; 1. built-in elisp function:
(provide-gptel-symbol-definition "ivy-read")
;; 2. built-in C function:
(provide-gptel-symbol-definition "find-file")
;; 3. function with multiple xref matches
(provide-gptel-symbol-definition "ivy-avy")
;; 4. function I wrote:
(provide-gptel-symbol-definition "mac-pvs")
;; 5. variable:
(provide-gptel-symbol-definition "find-function-C-source-directory")

(gptel-make-tool
 :name "read_source_definition"
 :function #'provide-gptel-symbol-definition
 :description "Get a symbol's definition from source code"
 :args (list '(:name "name"
               :type string
               :description "The name of the function or
                             variable whose documentation
                             is to be retrieved"))
 :category "emacs")

(defun provide-gptel-symbol-file (symbol)
  "Locate the file that symbol is defined in, then extract the text from that file to provide to 'gptel'."
  (let ((current-buf (current-buffer))
        (code-file)
        (code-content))

    (cond
     ;; no 'xref' matches to symbol:
     ((= 0 (length
            (xref-backend-definitions
             (xref-find-backend) symbol)))
      (setq code-content "Multiple or no matches to symbol.
                            Can't provide code."))
     
     ;; more than 'xref' 1 match to symbol:
     ((< 0 (length
            (xref-backend-definitions
             (xref-find-backend) symbol)))
      (let* ((xrefs (xref-backend-definitions
                     (xref-find-backend)
                     symbol)))
        (dolist (xr xrefs)
          (let* ((location (xref-item-location xr))
                 (marker (xref-location-marker location)))
            (with-current-buffer (marker-buffer marker)
              (setq code-content (concat
                              "\n"
                              code-content
                              (buffer-substring-no-properties
                               (point-min) (point-max)))))
          (kill-buffer (marker-buffer marker))))))
     )
    code-content))

;; examples of testing this function:
;; 1. built-in elisp function:
(provide-gptel-symbol-file "ivy-read")
;; 2. built-in C function:
(provide-gptel-symbol-file "find-file")
;; 3. function with multiple xref matches
(provide-gptel-symbol-file "ivy-avy")
;; 4. function I wrote:
(provide-gptel-symbol-file "mac-pvs")
;; 5. variable:
(provide-gptel-symbol-file "find-function-C-source-directory")

(gptel-make-tool
 :name "read_source_definition_full_file"
 :function #'provide-gptel-symbol-file
 :description "Get the full file that contains a symbol's definition."
 :args (list '(:name "name"
               :type string
               :description "The name of the function or
                             variable whose documentation
                             is to be retrieved"))
 :category "emacs")
#+END_SRC

* Reading R Documentation
These functions use ESS (Emacs Speaks Statistics) help functionality to provide
the documentation for R functions to gptel.  Note that the openai models (and
likely others) can already access much of this information from the web.
However, the tool seems to do a better job with less commonly used functions and
functions from user-installed packages.   

#+BEGIN_SRC emacs-lisp :results silent 
(defun get-R-help-content-for-gptel (arg)
  "Provide the documentation for an R object to 'gptel'."
  (interactive)
  (let ((R-content))
    (when (bufferp "*R-documentation*")
      (with-current-buffer (get-buffer "*R-documentation*")
        (delete-region (point-min) (point-max)))
      )
    (with-current-buffer
        (get-buffer-create "*R-documentation*")
      (ess--flush-help-into-current-buffer arg nil)
      (setq R-content (buffer-substring-no-properties
                       (point-min) (point-max))))
    (when (bufferp "*R-documentation*")
      (kill-buffer (get-buffer "*R-documentation*"))
      )
    R-content))

(gptel-make-tool
 :function #'get-R-help-content-for-gptel
 :name "read_R_help_documentation"
 :description "Read the help page for an R topic"
 :args (list '(:name "function"
                     :type string
                     :description "The specific function you'd like help on"))
 :category "R")

(gptel-make-preset 'rreader
  :description  "Use the R help pages to assist the user"
  :tools        '("read_R_help_documentation"))

;; test prompt:
;; read the help page for the R function "xyplot" and provide a slightly altered version of one of the plot calls
#+END_SRC

* Switching Models
#+BEGIN_SRC emacs-lisp :results silent 
;; taken from: https://github.com/karthink/gptel/issues/1066
(defun gptel-pick-model ()
  "Pick the model for gptel to use for queries."
  (interactive)
  (let* ((all-models-list
          (apply #'append
                 (mapcar (lambda (backend-entry)
                           (let ((name (car backend-entry))
                                 (backend (cdr backend-entry)))
                             (mapcar (lambda (model)
                                       (cons (concat name ":" (gptel--model-name model))
                                             (list backend model)))
                                     (gptel-backend-models backend))))
                         gptel--known-backends)))
         (filtered-models (cl-remove-if #'null all-models-list))
         (choice (completing-read "Model: " filtered-models nil t nil nil
                                  (concat (gptel-backend-name gptel-backend) ":"
                                          (gptel--model-name gptel-model)))))
    (let ((backend-model (cdr (assoc choice filtered-models))))
      (setq gptel-backend (car backend-model))
      (setq gptel-model (cadr backend-model))
      (message "Switched to %s model: %s"
               (gptel-backend-name gptel-backend)
               (gptel--model-name gptel-model)))))
#+END_SRC

* org-mode
#+BEGIN_SRC emacs-lisp 
(defun gptel-add-buffers-headings-to-context ()
  "Look through the list of org buffers and headings and return the best buffer / heading combination that matches the user's query."
  (interactive)
  (let ((entries)
        (contents)
        (buffers)
        (headings))
    ;; (dolist (b (nthcdr 100 (reverse (buffer-list))))
    (dolist (b (mapcar
                (lambda (arg) (get-buffer arg))
                '(
                  "r_notes.org"
                  ;; "agenda.org"
                  "latex_notes.org"
                  ;; "shell_notes.org"
)))
      (with-current-buffer b
        (when (and (derived-mode-p 'org-mode)
                   (not (string= (buffer-name) "time.org")))
                   ;; (and (string= (buffer-name) "r_notes.org")))
          (setq entries
                (nconc entries
                       (counsel-outline-candidates
                        (cdr (assq 'org-mode counsel-outline-settings))
                        (counsel-org-goto-all--outline-path-prefix))))))
    (dolist (e entries)
        (setq contents (cons (substring-no-properties (car e))
                             contents))))
    (setq contents (reverse contents)
          buffers (mapcar (lambda (b) (car (string-split b "/"))) contents)
          headings (mapcar (lambda (b) (cadr (string-split b "/"))) contents))
    (with-current-buffer (get-buffer-create "this_test")
      (delete-region (point-min) (point-max))
      (mapcar (lambda (c) (insert (concat c "\n"))) contents)
      (mark-whole-buffer)
      (gptel-context-add))
    ))

(defun gptel-switch-to-relevant-buffer-heading (buffer heading)
  "Switch to the buffer relevant to the user's query."
  (gptel-add-buffers-headings-to-context)
  (sit-for 5)
  (if (yes-or-no-p (concat "Switch to " buffer "? "))
      (switch-to-buffer (get-buffer buffer))
    (message (concat "not switching to" buffer ".")))
  (if (yes-or-no-p (concat "Jump to " heading "? "))
      (progn
        (goto-char (point-min))
        (re-search-forward heading nil t))
    (message (concat "not jumping to" heading ".")))
  (gptel-context-remove-all))

(gptel-make-tool
 :function #'gptel-switch-to-relevant-buffer-heading
 :name "2-get_org_buffer_and_switch_and_jump"
 :description "Return the org buffer and heading
               that best matches the user's query
               using the information supplied as context."
 :args (list '(:name "buffer"
               :type string
               :description "The buffer with the information you're looking
                             for.")
             '(:name "heading"
               :type string
               :description "The heading you'd like to jump to."))

 :category "org")

(gptel-context-remove-all)


(gptel-make-preset
    'org-finder-3
  :description  "Help the user find buffers and headings that match a topic"
  :tools        '("get_org_buffer_and_heading"))

#+END_SRC

* Brave and Web Search
#+BEGIN_SRC emacs-lisp :results silent
(defvar brave-search-api-key (auth-source-pick-first-password :host "api.brave.com")
  "API key for accessing the Brave Search API.")

(defun brave-search-query (query)
  "Perform a web search using the Brave Search API with the given QUERY."
  (let ((url-request-method "GET")
        (url-request-extra-headers `(("X-Subscription-Token" . ,brave-search-api-key)))
        (url (format "https://api.search.brave.com/res/v1/web/search?q=%s" (url-encode-url query))))
    (with-current-buffer (url-retrieve-synchronously url)
      (goto-char (point-min))
      (when (re-search-forward "^$" nil 'move)
        (let ((json-object-type 'hash-table)) ; Use hash-table for JSON parsing
          (json-parse-string (buffer-substring-no-properties (point) (point-max))))))))

(gptel-make-tool
 :name "brave_search"
 :function #'brave-search-query
 :name "brave_search"
 :description "Perform a web search using the Brave Search API"
 :args (list '(:name "query"
               :type string
               :description "The search query string"))
 :category "web")

(gptel-make-preset 'websearch
  :description  "search the web with brave"
  :tools        '("brave_search"))
#+END_SRC

* Email
#+BEGIN_SRC emacs-lisp 
(with-current-buffer (get-buffer-create "test")
  (delete-region (point-min) (point-max))
  (maphash (lambda (key val)
             (insert key))
           mu4e~contacts)
  (gptel-context--add-region
   (current-buffer) (point-min) (point-max) t))

(defun gptel-compose-email (address message)
  "Switch to the buffer relevant to the user's query."
  (progn
    (mu4e-context-switch t "proton - mac230@mahlon.net")
    (mu4e-compose-new))
  (if (yes-or-no-p (concat "Switch to " buffer "? "))
      (switch-to-buffer (get-buffer buffer))
    (message (concat "not switching to" buffer ".")))
  (if (yes-or-no-p (concat "Jump to " heading "? "))
      (progn
        (goto-char (point-min))
        (re-search-forward heading nil t))
    (message (concat "not jumping to" heading ".")))
  (gptel-context-remove-all))

(gptel-make-tool
 :function #'gptel-switch-to-relevant-buffer-heading
 :name "2-get_org_buffer_and_switch_and_jump"
 :description "Return the org buffer and heading
               that best matches the user's query
               using the information supplied as context."
 :args (list '(:name "buffer"
               :type string
               :description "The buffer with the information you're looking
                             for.")
             '(:name "heading"
               :type string
               :description "The heading you'd like to jump to."))

 :category "org")
#+END_SRC

* Debugging
** Processing pdfs Not Working / Supported
https://github.com/karthink/gptel/issues/756

I've had issues with certain models not send pdf content to models.  The github
issue above has code that can diagnose why this is happening at the level of
individual models:

#+BEGIN_SRC emacs-lisp :results silent 

;; what are the model's capabilities (need media):
(gptel--model-capabilities 'gemini-pro-latest)
(gptel--model-capabilities 'claude-3-7-sonnet-20250219)
(gptel--model-capabilities 'gpt-4.1)
;; (media tool-use json url)

;; what file types does it support (need 'application/pdf'):
(gptel--model-mimes 'gemini-1.5-pro-latest)
(gptel--model-mimes 'gemini-2.0-flash-exp)
(gptel--model-mimes 'claude-3-7-sonnet-20250219)
(gptel--model-mimes 'gpt-4.1)
;; ("image/png" "image/jpeg" "image/webp" "image/heic"
;; "image/heif" "application/pdf" "text/plain" "text/csv"
;; "text/html")

;; whether to send supported media via chat buffers
gptel-track-media

;; I was specifically having issues sending pdfs to gemini
;; models, but it works with the following configuration:
(gptel-make-gemini "gtest"
  :stream t
  :key (auth-source-pick-first-password :host "api.google.com")
  :models 
  '((gemini-2.0-flash-exp
     :description "model that accepts pdfs "
     :capabilities (tool-use json media)
     :mime-types ("image/png" "image/jpeg" "image/webp" "image/heic" "image/heif"
                  "application/pdf" "text/plain" "text/csv" "text/html"))
    (gemini-pro-latest
     :description "model that doesn't accept pdfs "
     :capabilities (tool-use json media)
     :mime-types ("image/png" "image/jpeg" "image/webp" "image/heic" "image/heif"
                  "application/pdf" "text/plain" "text/csv" "text/html"))))

#+END_SRC

* gptel Custom Commands

#+BEGIN_SRC emacs-lisp 
(defvar gptel-lookup--history nil)

;; prompt from the minibuffer, insert text at point:
(defun gptel-minibuffer-prompt-buffer-insertion (prompt)
  (interactive (list (read-string "prompt: " nil gptel-lookup--history)))
  (when (string= prompt "") (user-error "A prompt is required."))
  (gptel-request
   prompt
   :callback
   (lambda (response info)
     (if (not response)
         (message "gptel-lookup failed with message: %s" (plist-get info :status))
           (insert response)))))
#+END_SRC
